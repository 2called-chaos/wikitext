/** \file
 *  This C source file was generated by $ANTLR version 3.0.1
 *
 *     -  From the grammar source file : WikiText.g
 *     -                            On : 2007-10-16 01:51:25
 *     -                 for the lexer : WikiTextLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
*/
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "WikiTextLexer.h"
/* ----------------------------------------- */


/** String literals used by WikiTextLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x3C, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3D, 0x3D, 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x3D, 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x3A, 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x5B, 0x5B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x5D, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x26, 0x23, 0x78,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x26, 0x23,  ANTLR3_STRING_TERMINATOR};


/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pWikiTextLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pWikiTextLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pWikiTextLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence.
 */
 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define	    RULEMEMO				RECOGNIZER->ruleMemo
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXER->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXER->token
#define	    HASFAILED()				(RECOGNIZER->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			RECOGNIZER->backtracking
#define	    FAILEDFLAG				RECOGNIZER->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		INDEX()					INPUT->istream->index(INPUT->istream)
#define		SEEK(n)					INPUT->istream->seek(INPUT->istream, n)
#define	    EOF_TOKEN				&(LEXER->tokSource->eofToken)
#define	    HASEXCEPTION()			(RECOGNIZER->error == ANTLR3_TRUE)
#define	    EXCEPTION				RECOGNIZER->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					INPUT->istream->mark(INPUT->istream)
#define	    REWIND(m)				INPUT->istream->rewind(INPUT->istream, m)
#define	    REWINDLAST()			INPUT->istream->rewindLast(INPUT->istream)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXER->text = str
#define		USER1					LEXER->user1
#define		USER2					LEXER->user2
#define		USER3					LEXER->user3
#define		CUSTOM					LEXER->custom

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers wiht a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))					\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;										\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);	\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare implementation function for ANTLR3_TOKEN_SOURCE interface when
 * this is a fliter mode lexer.
 */
static pANTLR3_COMMON_TOKEN WikiTextLexerNextToken   (pANTLR3_TOKEN_SOURCE toksource);

/* Override the normal MEMOIZE and HAVEALREADYPARSED macros as this is a filtering
 * lexer. In filter mode, the memoizing and backtracking are gated at BACKTRACKING > 1 rather
 * than just BACKTRACKING. IN some cases this might generate code akin to:
 *   if (BACKTRACKING) if (BACKTRACKING > 1) memoize.
 * However, I assume that the C compilers/optimizers are smart enough to work this one out
 * these days - Jim
 */
#undef		MEMOIZE
#define		MEMOIZE(ri,si)			if (BACKTRACKING>1) { RECOGNIZER->memoize(RECOGNIZER, ri, si) }
#undef		HAVEPARSEDRULE
#define		HAVEPARSEDRULE(r)		if (BACKTRACKING>1) { RECOGNIZER->alreadyParsedRule(RECOGNIZER, r) }
/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE void	mPRE    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mNO_WIKI_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mNO_WIKI_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mBLOCKQUOTE    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSTRONG_EM    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSTRONG    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mEM    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mTT_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mTT_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mOL    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mUL    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH6    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH5    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH4    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH3    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH2    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH1    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH6_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH5_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH4_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH3_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH2_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH1_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH6_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH5_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH4_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH3_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH2_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mH1_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mURI    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mHTTP    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mFTP    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSVN    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mURI_CHARS    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSPECIAL_URI_CHARS    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mLINK_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mLINK_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mEXT_LINK_START    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mEXT_LINK_END    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSEPARATOR    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mSPACE    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mENTITY    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mNAMED_ENTITY    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mHEX_ENTITY    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mDECIMAL_ENTITY    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mQUOT    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mAMP    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mLESS    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mGREATER    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mCRLF    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mPRINTABLE    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mDEFAULT    (pWikiTextLexer ctx);
static ANTLR3_INLINE void	mTokens    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred1    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred2    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred3    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred4    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred5    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred6    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred7    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred8    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred9    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred10    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred11    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred12    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred13    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred14    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred15    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred16    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred17    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred18    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred19    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred20    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred21    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred22    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred23    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred24    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred25    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred26    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred27    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred28    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred29    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred30    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred31    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred32    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred33    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred34    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred35    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred36    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred37    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred38    (pWikiTextLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred39    (pWikiTextLexer ctx);
static void	WikiTextLexerFree(pWikiTextLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */




  // convenience macro for calling GETCHARPOSITIONINLINE using a more compact form
  #define COLUMN GETCHARPOSITIONINLINE()

  // convenience macro for pulling out the last-remembered token by accessing the userp field
  #define LAST_TOKEN ((ANTLR3_UINT32)ctx->pLexer->rec->userp)



static void
WikiTextLexerFree  (pWikiTextLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "WikiText.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

    /** An override of the lexer's nextToken() method that backtracks over mTokens() looking
     *  for matches in lexer filterMode.  No error can be generated upon error; just rewind, consume
     *  a token and then try again.  BACKTRACKING needs to be set as well.
     *  Make rule memoization happen only at levels above 1 as we start mTokens
     *  at BACKTRACKING==1.
     */
    static pANTLR3_COMMON_TOKEN 
    WikiTextLexerNextToken(pANTLR3_TOKEN_SOURCE toksource) 
    {
        pANTLR3_LEXER   lexer;

        lexer   = (pANTLR3_LEXER)(toksource->super);
        
        /* Get rid of any previous token (token factory takes care of
         * any deallocation when this token is finally used up.
         */
        lexer		->token	    = NULL;
        lexer->rec	->error	    = ANTLR3_FALSE;	    /* Start out without an exception	*/
        lexer->rec	->failed    = ANTLR3_FALSE;

        /* Record the start of the token in our input stream.
         */
        lexer->tokenStartCharIndex			= lexer->input->istream->index(lexer->input->istream);
        lexer->tokenStartCharPositionInLine	= lexer->input->getCharPositionInLine(lexer->input);
        lexer->tokenStartLine				= lexer->input->getLine(lexer->input);
        lexer->text							= NULL;

        /* Now call the matching rules and see if we can generate a new token
         */
        for	(;;)
        {
    		if  (lexer->input->istream->_LA(lexer->input->istream, 1) == ANTLR3_CHARSTREAM_EOF)
    		{
    			/* Reached the end of the stream, nothing more to do.
    			 */
    			pANTLR3_COMMON_TOKEN    teof = &(toksource->eofToken);

    			teof->setStartIndex (teof, lexer->getCharIndex(lexer));
    			teof->setStopIndex  (teof, lexer->getCharIndex(lexer));
    			teof->setLine		(teof, lexer->getLine(lexer));
    			return  teof;
    		}
    		
    		lexer->token		= NULL;
    		lexer->rec->error	= ANTLR3_FALSE;	    /* Start out without an exception	*/
    		
    		{
    			ANTLR3_UINT64   m;
    		    
    			m							= lexer->input->istream->mark(lexer->input->istream);
    			lexer->rec->backtracking	= 1;				/* No exceptions */
    			lexer->rec->failed			= ANTLR3_FALSE;
    		 
    			/* Call the generated lexer, see if it can get a new token together.
    			 */
    			lexer->mTokens(lexer->ctx);   
        		lexer->rec->backtracking	= 0;
    	    	    

    	               
    			if	(lexer->rec->failed == ANTLR3_TRUE)
    			{
    				lexer->input->istream->rewind(lexer->input->istream, m);
    				lexer->input->istream->consume(lexer->input->istream); 
    			}
    			else
    			{
    				lexer->emit(lexer);					/* Assemble the token and emit it to the stream */
    				return	lexer->token;
    			}	
    		}
        }
    }
/** \brief Create a new lexer called WikiTextLexer
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success pWikiTextLexer initialized for the lex start
 *     - Fail (pWikiTextLexer)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API pWikiTextLexer WikiTextLexerNew         (pANTLR3_INPUT_STREAM     instream)
{
    pWikiTextLexer lexCtx; /* Context structure we will build and return   */

    lexCtx = (pWikiTextLexer) ANTLR3_MALLOC(sizeof(WikiTextLexer));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (pWikiTextLexer)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in WikiTextLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

    /* Check that we allocated the memory correctly
     */
    if	(lexCtx->pLexer == (pANTLR3_LEXER)ANTLR3_ERR_NOMEM)
    {
	ANTLR3_FREE(lexCtx);
	return  (pWikiTextLexer)ANTLR3_ERR_NOMEM;
    }
    /* Install the implementation of our WikiTextLexer interface
     */
    lexCtx->mPRE	= mPRE;
    lexCtx->mNO_WIKI_START	= mNO_WIKI_START;
    lexCtx->mNO_WIKI_END	= mNO_WIKI_END;
    lexCtx->mBLOCKQUOTE	= mBLOCKQUOTE;
    lexCtx->mSTRONG_EM	= mSTRONG_EM;
    lexCtx->mSTRONG	= mSTRONG;
    lexCtx->mEM	= mEM;
    lexCtx->mTT_START	= mTT_START;
    lexCtx->mTT_END	= mTT_END;
    lexCtx->mOL	= mOL;
    lexCtx->mUL	= mUL;
    lexCtx->mH6	= mH6;
    lexCtx->mH5	= mH5;
    lexCtx->mH4	= mH4;
    lexCtx->mH3	= mH3;
    lexCtx->mH2	= mH2;
    lexCtx->mH1	= mH1;
    lexCtx->mH6_START	= mH6_START;
    lexCtx->mH5_START	= mH5_START;
    lexCtx->mH4_START	= mH4_START;
    lexCtx->mH3_START	= mH3_START;
    lexCtx->mH2_START	= mH2_START;
    lexCtx->mH1_START	= mH1_START;
    lexCtx->mH6_END	= mH6_END;
    lexCtx->mH5_END	= mH5_END;
    lexCtx->mH4_END	= mH4_END;
    lexCtx->mH3_END	= mH3_END;
    lexCtx->mH2_END	= mH2_END;
    lexCtx->mH1_END	= mH1_END;
    lexCtx->mURI	= mURI;
    lexCtx->mHTTP	= mHTTP;
    lexCtx->mFTP	= mFTP;
    lexCtx->mSVN	= mSVN;
    lexCtx->mURI_CHARS	= mURI_CHARS;
    lexCtx->mSPECIAL_URI_CHARS	= mSPECIAL_URI_CHARS;
    lexCtx->mLINK_START	= mLINK_START;
    lexCtx->mLINK_END	= mLINK_END;
    lexCtx->mEXT_LINK_START	= mEXT_LINK_START;
    lexCtx->mEXT_LINK_END	= mEXT_LINK_END;
    lexCtx->mSEPARATOR	= mSEPARATOR;
    lexCtx->mSPACE	= mSPACE;
    lexCtx->mENTITY	= mENTITY;
    lexCtx->mNAMED_ENTITY	= mNAMED_ENTITY;
    lexCtx->mHEX_ENTITY	= mHEX_ENTITY;
    lexCtx->mDECIMAL_ENTITY	= mDECIMAL_ENTITY;
    lexCtx->mQUOT	= mQUOT;
    lexCtx->mAMP	= mAMP;
    lexCtx->mLESS	= mLESS;
    lexCtx->mGREATER	= mGREATER;
    lexCtx->mCRLF	= mCRLF;
    lexCtx->mPRINTABLE	= mPRINTABLE;
    lexCtx->mDEFAULT	= mDEFAULT;
    lexCtx->mTokens	= mTokens;







































    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    lexCtx->getGrammarFileName	= getGrammarFileName;
    lexCtx->free		= WikiTextLexerFree;
    
    /* We have filter mode turned on, so install the filtering nextToken function
     */
    lexCtx->pLexer->tokSource->nextToken = WikiTextLexerNextToken;
	 
    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}
 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 27:17: ({...}? => ' ' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRE
 *
 * Looks to match the characters the constitute the token PRE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRE(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = PRE;
       
    
    // WikiText.g:27:17: ({...}? => ' ' )
    // WikiText.g:27:19: {...}? => ' '
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "PRE";


        }
        MATCHC(' '); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePREEx; /* Prevent compiler warnings */
    rulePREEx: ;

}
// $ANTLR end PRE

//   Comes from: 32:17: ( '<' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NO_WIKI_START
 *
 * Looks to match the characters the constitute the token NO_WIKI_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNO_WIKI_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = NO_WIKI_START;
       
    
    // WikiText.g:32:17: ( '<' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>' )
    // WikiText.g:32:19: '<' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>'
    {
        MATCHC('<'); 
        if (HASFAILED())
        {
            return ;
        }
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_STARTEx;
        }

        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNO_WIKI_STARTEx; /* Prevent compiler warnings */
    ruleNO_WIKI_STARTEx: ;

}
// $ANTLR end NO_WIKI_START

//   Comes from: 33:17: ( '</' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NO_WIKI_END
 *
 * Looks to match the characters the constitute the token NO_WIKI_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNO_WIKI_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = NO_WIKI_END;
       
    
    // WikiText.g:33:17: ( '</' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>' )
    // WikiText.g:33:19: '</' ( 'n' | 'N' ) ( 'o' | 'O' ) ( 'w' | 'W' ) ( 'i' | 'I' ) ( 'k' | 'K' ) ( 'i' | 'I' ) '>'
    {
        MATCHS(lit_1); 
        if (HASFAILED())
        {
            return ;
        }

        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleNO_WIKI_ENDEx;
        }

        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNO_WIKI_ENDEx; /* Prevent compiler warnings */
    ruleNO_WIKI_ENDEx: ;

}
// $ANTLR end NO_WIKI_END

//   Comes from: 36:17: ({...}? => '>' ( ' ' )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BLOCKQUOTE
 *
 * Looks to match the characters the constitute the token BLOCKQUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBLOCKQUOTE(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = BLOCKQUOTE;
       
    
    // WikiText.g:36:17: ({...}? => '>' ( ' ' )? )
    // WikiText.g:36:19: {...}? => '>' ( ' ' )?
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "BLOCKQUOTE";


        }
        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

        // WikiText.g:36:70: ( ' ' )?
        {
            int alt1=2;
            {
                int LA1_0 = LA(1);
                if ( (LA1_0 == ' ') ) 
                {
                    alt1=1;
                }
            }
            switch (alt1) 
            {
        	case 1:
        	    // WikiText.g:36:70: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBLOCKQUOTEEx; /* Prevent compiler warnings */
    ruleBLOCKQUOTEEx: ;

}
// $ANTLR end BLOCKQUOTE

//   Comes from: 39:17: ( '\\'' '\\'' '\\'' '\\'' '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRONG_EM
 *
 * Looks to match the characters the constitute the token STRONG_EM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRONG_EM(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = STRONG_EM;
       
    
    // WikiText.g:39:17: ( '\\'' '\\'' '\\'' '\\'' '\\'' )
    // WikiText.g:39:19: '\\'' '\\'' '\\'' '\\'' '\\''
    {
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRONG_EMEx; /* Prevent compiler warnings */
    ruleSTRONG_EMEx: ;

}
// $ANTLR end STRONG_EM

//   Comes from: 40:17: ( '\\'' '\\'' '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRONG
 *
 * Looks to match the characters the constitute the token STRONG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRONG(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = STRONG;
       
    
    // WikiText.g:40:17: ( '\\'' '\\'' '\\'' )
    // WikiText.g:40:19: '\\'' '\\'' '\\''
    {
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRONGEx; /* Prevent compiler warnings */
    ruleSTRONGEx: ;

}
// $ANTLR end STRONG

//   Comes from: 41:17: ( '\\'' '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EM
 *
 * Looks to match the characters the constitute the token EM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEM(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = EM;
       
    
    // WikiText.g:41:17: ( '\\'' '\\'' )
    // WikiText.g:41:19: '\\'' '\\''
    {
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('\''); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEMEx; /* Prevent compiler warnings */
    ruleEMEx: ;

}
// $ANTLR end EM

//   Comes from: 43:17: ( '<' ( 't' | 'T' ) ( 't' | 'T' ) '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TT_START
 *
 * Looks to match the characters the constitute the token TT_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTT_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = TT_START;
       
    
    // WikiText.g:43:17: ( '<' ( 't' | 'T' ) ( 't' | 'T' ) '>' )
    // WikiText.g:43:19: '<' ( 't' | 'T' ) ( 't' | 'T' ) '>'
    {
        MATCHC('<'); 
        if (HASFAILED())
        {
            return ;
        }
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTT_STARTEx;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTT_STARTEx;
        }

        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTT_STARTEx; /* Prevent compiler warnings */
    ruleTT_STARTEx: ;

}
// $ANTLR end TT_START

//   Comes from: 44:17: ( '</' ( 't' | 'T' ) ( 't' | 'T' ) '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TT_END
 *
 * Looks to match the characters the constitute the token TT_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTT_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = TT_END;
       
    
    // WikiText.g:44:17: ( '</' ( 't' | 'T' ) ( 't' | 'T' ) '>' )
    // WikiText.g:44:19: '</' ( 't' | 'T' ) ( 't' | 'T' ) '>'
    {
        MATCHS(lit_1); 
        if (HASFAILED())
        {
            return ;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTT_ENDEx;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleTT_ENDEx;
        }

        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTT_ENDEx; /* Prevent compiler warnings */
    ruleTT_ENDEx: ;

}
// $ANTLR end TT_END

//   Comes from: 48:17: ({...}? => '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OL
 *
 * Looks to match the characters the constitute the token OL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOL(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = OL;
       
    
    // WikiText.g:48:17: ({...}? => '#' )
    // WikiText.g:48:19: {...}? => '#'
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == OL || LAST_TOKEN == UL || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == OL || LAST_TOKEN == UL || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "OL";


        }
        MATCHC('#'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOLEx; /* Prevent compiler warnings */
    ruleOLEx: ;

}
// $ANTLR end OL

//   Comes from: 49:17: ({...}? => '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UL
 *
 * Looks to match the characters the constitute the token UL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUL(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = UL;
       
    
    // WikiText.g:49:17: ({...}? => '*' )
    // WikiText.g:49:19: {...}? => '*'
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == UL || LAST_TOKEN == OL || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == UL || LAST_TOKEN == OL || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "UL";


        }
        MATCHC('*'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleULEx; /* Prevent compiler warnings */
    ruleULEx: ;

}
// $ANTLR end UL

//   Comes from: 51:17: ( '======' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H6
 *
 * Looks to match the characters the constitute the token H6
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH6(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:51:17: ( '======' )
    // WikiText.g:51:19: '======'
    {
        MATCHS(lit_2); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleH6Ex; /* Prevent compiler warnings */
    ruleH6Ex: ;

}
// $ANTLR end H6

//   Comes from: 52:17: ( '=====' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H5
 *
 * Looks to match the characters the constitute the token H5
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH5(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:52:17: ( '=====' )
    // WikiText.g:52:19: '====='
    {
        MATCHS(lit_3); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleH5Ex; /* Prevent compiler warnings */
    ruleH5Ex: ;

}
// $ANTLR end H5

//   Comes from: 53:17: ( '====' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H4
 *
 * Looks to match the characters the constitute the token H4
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH4(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:53:17: ( '====' )
    // WikiText.g:53:19: '===='
    {
        MATCHS(lit_4); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleH4Ex; /* Prevent compiler warnings */
    ruleH4Ex: ;

}
// $ANTLR end H4

//   Comes from: 54:17: ( '===' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H3
 *
 * Looks to match the characters the constitute the token H3
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH3(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:54:17: ( '===' )
    // WikiText.g:54:19: '==='
    {
        MATCHS(lit_5); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleH3Ex; /* Prevent compiler warnings */
    ruleH3Ex: ;

}
// $ANTLR end H3

//   Comes from: 55:17: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H2
 *
 * Looks to match the characters the constitute the token H2
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH2(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:55:17: ( '==' )
    // WikiText.g:55:19: '=='
    {
        MATCHS(lit_6); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleH2Ex; /* Prevent compiler warnings */
    ruleH2Ex: ;

}
// $ANTLR end H2

//   Comes from: 56:17: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H1
 *
 * Looks to match the characters the constitute the token H1
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH1(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:56:17: ( '=' )
    // WikiText.g:56:19: '='
    {
        MATCHC('='); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleH1Ex; /* Prevent compiler warnings */
    ruleH1Ex: ;

}
// $ANTLR end H1

//   Comes from: 59:17: ({...}? => H6 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H6_START
 *
 * Looks to match the characters the constitute the token H6_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH6_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H6_START;
       
    
    // WikiText.g:59:17: ({...}? => H6 )
    // WikiText.g:59:19: {...}? => H6
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H6_START";


        }
        /* 59:19: {...}? => H6 */
        mH6(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH6_STARTEx; /* Prevent compiler warnings */
    ruleH6_STARTEx: ;

}
// $ANTLR end H6_START

//   Comes from: 60:17: ({...}? => H5 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H5_START
 *
 * Looks to match the characters the constitute the token H5_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH5_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H5_START;
       
    
    // WikiText.g:60:17: ({...}? => H5 )
    // WikiText.g:60:19: {...}? => H5
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H5_START";


        }
        /* 60:19: {...}? => H5 */
        mH5(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH5_STARTEx; /* Prevent compiler warnings */
    ruleH5_STARTEx: ;

}
// $ANTLR end H5_START

//   Comes from: 61:17: ({...}? => H4 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H4_START
 *
 * Looks to match the characters the constitute the token H4_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH4_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H4_START;
       
    
    // WikiText.g:61:17: ({...}? => H4 )
    // WikiText.g:61:19: {...}? => H4
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H4_START";


        }
        /* 61:19: {...}? => H4 */
        mH4(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH4_STARTEx; /* Prevent compiler warnings */
    ruleH4_STARTEx: ;

}
// $ANTLR end H4_START

//   Comes from: 62:17: ({...}? => H3 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H3_START
 *
 * Looks to match the characters the constitute the token H3_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH3_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H3_START;
       
    
    // WikiText.g:62:17: ({...}? => H3 )
    // WikiText.g:62:19: {...}? => H3
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H3_START";


        }
        /* 62:19: {...}? => H3 */
        mH3(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH3_STARTEx; /* Prevent compiler warnings */
    ruleH3_STARTEx: ;

}
// $ANTLR end H3_START

//   Comes from: 63:17: ({...}? => H2 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H2_START
 *
 * Looks to match the characters the constitute the token H2_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH2_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H2_START;
       
    
    // WikiText.g:63:17: ({...}? => H2 )
    // WikiText.g:63:19: {...}? => H2
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H2_START";


        }
        /* 63:19: {...}? => H2 */
        mH2(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH2_STARTEx; /* Prevent compiler warnings */
    ruleH2_STARTEx: ;

}
// $ANTLR end H2_START

//   Comes from: 64:17: ({...}? => H1 )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H1_START
 *
 * Looks to match the characters the constitute the token H1_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH1_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H1_START;
       
    
    // WikiText.g:64:17: ({...}? => H1 )
    // WikiText.g:64:19: {...}? => H1
    {
        if ( !( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) ) 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                EXCEPTION->message      = " COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ";
                EXCEPTION->ruleName	 = "H1_START";


        }
        /* 64:19: {...}? => H1 */
        mH1(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH1_STARTEx; /* Prevent compiler warnings */
    ruleH1_STARTEx: ;

}
// $ANTLR end H1_START

//   Comes from: 67:17: ( H6 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H6_END
 *
 * Looks to match the characters the constitute the token H6_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH6_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H6_END;
       
    
    // WikiText.g:67:17: ( H6 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:67:19: H6 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 67:19: H6 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH6(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:67:34: ( ' ' )*

        for (;;)
        {
            int alt2=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                if ( (LA2_0 == ' ') ) 
                {
                    alt2=1;
                }

            }
            switch (alt2) 
            {
        	case 1:
        	    // WikiText.g:67:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */


        // WikiText.g:67:39: ( '\\n' | '\\r' | EOF )
        {
            int alt3=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt3=1;
            	}
                break;
            case '\r':
            	{
            		alt3=2;
            	}
                break;

            default:
                alt3=3;}

            switch (alt3) 
            {
        	case 1:
        	    // WikiText.g:67:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:67:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:67:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH6_ENDEx; /* Prevent compiler warnings */
    ruleH6_ENDEx: ;

}
// $ANTLR end H6_END

//   Comes from: 68:17: ( H5 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H5_END
 *
 * Looks to match the characters the constitute the token H5_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH5_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H5_END;
       
    
    // WikiText.g:68:17: ( H5 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:68:19: H5 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 68:19: H5 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH5(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:68:34: ( ' ' )*

        for (;;)
        {
            int alt4=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA4_0 = LA(1);
                if ( (LA4_0 == ' ') ) 
                {
                    alt4=1;
                }

            }
            switch (alt4) 
            {
        	case 1:
        	    // WikiText.g:68:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop4;	/* break out of the loop */
        	    break;
            }
        }
        loop4: ; /* Jump out to here if this rule does not match */


        // WikiText.g:68:39: ( '\\n' | '\\r' | EOF )
        {
            int alt5=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt5=1;
            	}
                break;
            case '\r':
            	{
            		alt5=2;
            	}
                break;

            default:
                alt5=3;}

            switch (alt5) 
            {
        	case 1:
        	    // WikiText.g:68:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:68:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:68:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH5_ENDEx; /* Prevent compiler warnings */
    ruleH5_ENDEx: ;

}
// $ANTLR end H5_END

//   Comes from: 69:17: ( H4 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H4_END
 *
 * Looks to match the characters the constitute the token H4_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH4_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H4_END;
       
    
    // WikiText.g:69:17: ( H4 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:69:19: H4 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 69:19: H4 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH4(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:69:34: ( ' ' )*

        for (;;)
        {
            int alt6=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA6_0 = LA(1);
                if ( (LA6_0 == ' ') ) 
                {
                    alt6=1;
                }

            }
            switch (alt6) 
            {
        	case 1:
        	    // WikiText.g:69:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop6;	/* break out of the loop */
        	    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */


        // WikiText.g:69:39: ( '\\n' | '\\r' | EOF )
        {
            int alt7=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt7=1;
            	}
                break;
            case '\r':
            	{
            		alt7=2;
            	}
                break;

            default:
                alt7=3;}

            switch (alt7) 
            {
        	case 1:
        	    // WikiText.g:69:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:69:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:69:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH4_ENDEx; /* Prevent compiler warnings */
    ruleH4_ENDEx: ;

}
// $ANTLR end H4_END

//   Comes from: 70:17: ( H3 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H3_END
 *
 * Looks to match the characters the constitute the token H3_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH3_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H3_END;
       
    
    // WikiText.g:70:17: ( H3 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:70:19: H3 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 70:19: H3 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH3(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:70:34: ( ' ' )*

        for (;;)
        {
            int alt8=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA8_0 = LA(1);
                if ( (LA8_0 == ' ') ) 
                {
                    alt8=1;
                }

            }
            switch (alt8) 
            {
        	case 1:
        	    // WikiText.g:70:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop8;	/* break out of the loop */
        	    break;
            }
        }
        loop8: ; /* Jump out to here if this rule does not match */


        // WikiText.g:70:39: ( '\\n' | '\\r' | EOF )
        {
            int alt9=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt9=1;
            	}
                break;
            case '\r':
            	{
            		alt9=2;
            	}
                break;

            default:
                alt9=3;}

            switch (alt9) 
            {
        	case 1:
        	    // WikiText.g:70:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:70:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:70:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH3_ENDEx; /* Prevent compiler warnings */
    ruleH3_ENDEx: ;

}
// $ANTLR end H3_END

//   Comes from: 71:17: ( H2 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H2_END
 *
 * Looks to match the characters the constitute the token H2_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH2_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H2_END;
       
    
    // WikiText.g:71:17: ( H2 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:71:19: H2 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 71:19: H2 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH2(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:71:34: ( ' ' )*

        for (;;)
        {
            int alt10=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA10_0 = LA(1);
                if ( (LA10_0 == ' ') ) 
                {
                    alt10=1;
                }

            }
            switch (alt10) 
            {
        	case 1:
        	    // WikiText.g:71:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop10;	/* break out of the loop */
        	    break;
            }
        }
        loop10: ; /* Jump out to here if this rule does not match */


        // WikiText.g:71:39: ( '\\n' | '\\r' | EOF )
        {
            int alt11=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt11=1;
            	}
                break;
            case '\r':
            	{
            		alt11=2;
            	}
                break;

            default:
                alt11=3;}

            switch (alt11) 
            {
        	case 1:
        	    // WikiText.g:71:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:71:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:71:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH2_ENDEx; /* Prevent compiler warnings */
    ruleH2_ENDEx: ;

}
// $ANTLR end H2_END

//   Comes from: 72:17: ( H1 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start H1_END
 *
 * Looks to match the characters the constitute the token H1_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mH1_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = H1_END;
       
    
    // WikiText.g:72:17: ( H1 ( ' ' )* ( '\\n' | '\\r' | EOF ) )
    // WikiText.g:72:19: H1 ( ' ' )* ( '\\n' | '\\r' | EOF )
    {
        /* 72:19: H1 ( ' ' )* ( '\\n' | '\\r' | EOF ) */
        mH1(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==1 ) 
        {
             MARK(); 
        }

        // WikiText.g:72:34: ( ' ' )*

        for (;;)
        {
            int alt12=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA12_0 = LA(1);
                if ( (LA12_0 == ' ') ) 
                {
                    alt12=1;
                }

            }
            switch (alt12) 
            {
        	case 1:
        	    // WikiText.g:72:34: ' '
        	    {
        	        MATCHC(' '); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop12;	/* break out of the loop */
        	    break;
            }
        }
        loop12: ; /* Jump out to here if this rule does not match */


        // WikiText.g:72:39: ( '\\n' | '\\r' | EOF )
        {
            int alt13=3;
            switch ( LA(1) ) 
            {
            case '\n':
            	{
            		alt13=1;
            	}
                break;
            case '\r':
            	{
            		alt13=2;
            	}
                break;

            default:
                alt13=3;}

            switch (alt13) 
            {
        	case 1:
        	    // WikiText.g:72:41: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:72:48: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:72:55: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	    }
        	    break;

            }
        }
        if ( BACKTRACKING==1 ) 
        {
             REWINDLAST(); 
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleH1_ENDEx; /* Prevent compiler warnings */
    ruleH1_ENDEx: ;

}
// $ANTLR end H1_END

//   Comes from: 77:19: ( ( HTTP | FTP | SVN ) URI_CHARS ( ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start URI
 *
 * Looks to match the characters the constitute the token URI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mURI(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = URI;
       
    
    // WikiText.g:77:19: ( ( HTTP | FTP | SVN ) URI_CHARS ( ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS ) )* )
    // WikiText.g:77:21: ( HTTP | FTP | SVN ) URI_CHARS ( ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS ) )*
    {

        // WikiText.g:77:21: ( HTTP | FTP | SVN )
        {
            int alt14=3;
            switch ( LA(1) ) 
            {
            case 'H':
            case 'h':
            	{
            		alt14=1;
            	}
                break;
            case 'F':
            case 'f':
            	{
            		alt14=2;
            	}
                break;
            case 'S':
            case 's':
            	{
            		alt14=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "77:21: ( HTTP | FTP | SVN )";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleURIEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // WikiText.g:77:22: HTTP
        	    {
        	        /* 77:22: HTTP */
        	        mHTTP(ctx ); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // WikiText.g:77:29: FTP
        	    {
        	        /* 77:29: FTP */
        	        mFTP(ctx ); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // WikiText.g:77:35: SVN
        	    {
        	        /* 77:35: SVN */
        	        mSVN(ctx ); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        /* 77:21: ( HTTP | FTP | SVN ) URI_CHARS ( ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS ) )* */
        mURI_CHARS(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

        // WikiText.g:77:50: ( ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS ) )*

        for (;;)
        {
            int alt15=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA15_0 = LA(1);
                if ( (LA15_0 == '!' || LA15_0 == ')' || LA15_0 == ',' || LA15_0 == '.' || ((LA15_0 >= ':') && (LA15_0 <= ';')) || LA15_0 == '?') && (synpred1(ctx))) 
                {
                    alt15=1;
                }

            }
            switch (alt15) 
            {
        	case 1:
        	    // WikiText.g:77:51: ( SPECIAL_URI_CHARS URI_CHARS )=> ( SPECIAL_URI_CHARS URI_CHARS )
        	    {
        	        // WikiText.g:77:83: ( SPECIAL_URI_CHARS URI_CHARS )
        	        // WikiText.g:77:84: SPECIAL_URI_CHARS URI_CHARS
        	        {
        	            /* 77:84: SPECIAL_URI_CHARS URI_CHARS */
        	            mSPECIAL_URI_CHARS(ctx ); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            /* 77:84: SPECIAL_URI_CHARS URI_CHARS */
        	            mURI_CHARS(ctx ); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

        	default:
        	    goto loop15;	/* break out of the loop */
        	    break;
            }
        }
        loop15: ; /* Jump out to here if this rule does not match */


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleURIEx; /* Prevent compiler warnings */
    ruleURIEx: ;

}
// $ANTLR end URI

//   Comes from: 80:19: ( ( 'h' | 'H' ) ( 't' | 'T' ) ( 't' | 'T' ) ( 'p' | 'P' ) ( 's' | 'S' )? '://' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HTTP
 *
 * Looks to match the characters the constitute the token HTTP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHTTP(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:80:19: ( ( 'h' | 'H' ) ( 't' | 'T' ) ( 't' | 'T' ) ( 'p' | 'P' ) ( 's' | 'S' )? '://' )
    // WikiText.g:80:21: ( 'h' | 'H' ) ( 't' | 'T' ) ( 't' | 'T' ) ( 'p' | 'P' ) ( 's' | 'S' )? '://'
    {
        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHTTPEx;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHTTPEx;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHTTPEx;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHTTPEx;
        }


        // WikiText.g:80:69: ( 's' | 'S' )?
        {
            int alt16=2;
            {
                int LA16_0 = LA(1);
                if ( (LA16_0 == 'S' || LA16_0 == 's') ) 
                {
                    alt16=1;
                }
            }
            switch (alt16) 
            {
        	case 1:
        	    // WikiText.g:
        	    {
        	        if ( LA(1) == 'S' || LA(1) == 's' )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE; 
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleHTTPEx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHS(lit_7); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHTTPEx; /* Prevent compiler warnings */
    ruleHTTPEx: ;

}
// $ANTLR end HTTP

//   Comes from: 83:19: ( ( 'f' | 'F' ) ( 't' | 'T' ) ( 'p' | 'P' ) '://' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FTP
 *
 * Looks to match the characters the constitute the token FTP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFTP(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:83:19: ( ( 'f' | 'F' ) ( 't' | 'T' ) ( 'p' | 'P' ) '://' )
    // WikiText.g:83:21: ( 'f' | 'F' ) ( 't' | 'T' ) ( 'p' | 'P' ) '://'
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFTPEx;
        }

        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFTPEx;
        }

        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFTPEx;
        }

        MATCHS(lit_7); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFTPEx; /* Prevent compiler warnings */
    ruleFTPEx: ;

}
// $ANTLR end FTP

//   Comes from: 86:19: ( ( 's' | 'S' ) ( 'v' | 'V' ) ( 'n' | 'N' ) '://' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SVN
 *
 * Looks to match the characters the constitute the token SVN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSVN(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:86:19: ( ( 's' | 'S' ) ( 'v' | 'V' ) ( 'n' | 'N' ) '://' )
    // WikiText.g:86:21: ( 's' | 'S' ) ( 'v' | 'V' ) ( 'n' | 'N' ) '://'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSVNEx;
        }

        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSVNEx;
        }

        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSVNEx;
        }

        MATCHS(lit_7); 
        if (HASFAILED())
        {
            return ;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleSVNEx; /* Prevent compiler warnings */
    ruleSVNEx: ;

}
// $ANTLR end SVN

//   Comes from: 89:19: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '@' | '$' | '&' | '\\'' | '(' | '*' | '+' | '=' | '\\%' | '-' | '_' | '~' | '/' | '#' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start URI_CHARS
 *
 * Looks to match the characters the constitute the token URI_CHARS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mURI_CHARS(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:89:19: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '@' | '$' | '&' | '\\'' | '(' | '*' | '+' | '=' | '\\%' | '-' | '_' | '~' | '/' | '#' )+ )
    // WikiText.g:89:21: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '@' | '$' | '&' | '\\'' | '(' | '*' | '+' | '=' | '\\%' | '-' | '_' | '~' | '/' | '#' )+
    {
        // WikiText.g:89:21: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '@' | '$' | '&' | '\\'' | '(' | '*' | '+' | '=' | '\\%' | '-' | '_' | '~' | '/' | '#' )+
        {
            int cnt17=0;

            for (;;)
            {
                int alt17=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA17_0 = LA(1);
        	    if ( (((LA17_0 >= '#') && (LA17_0 <= '(')) || ((LA17_0 >= '*') && (LA17_0 <= '+')) || LA17_0 == '-' || ((LA17_0 >= '/') && (LA17_0 <= '9')) || LA17_0 == '=' || ((LA17_0 >= '@') && (LA17_0 <= 'Z')) || LA17_0 == '_' || ((LA17_0 >= 'a') && (LA17_0 <= 'z')) || LA17_0 == '~') ) 
        	    {
        	        alt17=1;
        	    }

        	}
        	switch (alt17) 
        	{
        	    case 1:
        	        // WikiText.g:
        	        {
        	            if ( ((LA(1) >= '#') && (LA(1) <= '(')) || ((LA(1) >= '*') && (LA(1) <= '+')) || LA(1) == '-' || ((LA(1) >= '/') && (LA(1) <= '9')) || LA(1) == '=' || ((LA(1) >= '@') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || LA(1) == '~' )
        	            {
        	                CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleURI_CHARSEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt17 >= 1 )
        		{
        		    goto loop17;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleURI_CHARSEx;
        	}
        	cnt17++;
            }
            loop17: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleURI_CHARSEx; /* Prevent compiler warnings */
    ruleURI_CHARSEx: ;

}
// $ANTLR end URI_CHARS

//   Comes from: 94:19: ( ( ':' | '!' | ')' | ',' | ';' | '.' | '?' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPECIAL_URI_CHARS
 *
 * Looks to match the characters the constitute the token SPECIAL_URI_CHARS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSPECIAL_URI_CHARS(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:94:19: ( ( ':' | '!' | ')' | ',' | ';' | '.' | '?' )+ )
    // WikiText.g:94:21: ( ':' | '!' | ')' | ',' | ';' | '.' | '?' )+
    {
        // WikiText.g:94:21: ( ':' | '!' | ')' | ',' | ';' | '.' | '?' )+
        {
            int cnt18=0;

            for (;;)
            {
                int alt18=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA18_0 = LA(1);
        	    if ( (LA18_0 == '!' || LA18_0 == ')' || LA18_0 == ',' || LA18_0 == '.' || ((LA18_0 >= ':') && (LA18_0 <= ';')) || LA18_0 == '?') ) 
        	    {
        	        alt18=1;
        	    }

        	}
        	switch (alt18) 
        	{
        	    case 1:
        	        // WikiText.g:
        	        {
        	            if ( LA(1) == '!' || LA(1) == ')' || LA(1) == ',' || LA(1) == '.' || ((LA(1) >= ':') && (LA(1) <= ';')) || LA(1) == '?' )
        	            {
        	                CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleSPECIAL_URI_CHARSEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt18 >= 1 )
        		{
        		    goto loop18;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleSPECIAL_URI_CHARSEx;
        	}
        	cnt18++;
            }
            loop18: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleSPECIAL_URI_CHARSEx; /* Prevent compiler warnings */
    ruleSPECIAL_URI_CHARSEx: ;

}
// $ANTLR end SPECIAL_URI_CHARS

//   Comes from: 96:17: ( '[[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINK_START
 *
 * Looks to match the characters the constitute the token LINK_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINK_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LINK_START;
       
    
    // WikiText.g:96:17: ( '[[' )
    // WikiText.g:96:19: '[['
    {
        MATCHS(lit_8); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINK_STARTEx; /* Prevent compiler warnings */
    ruleLINK_STARTEx: ;

}
// $ANTLR end LINK_START

//   Comes from: 97:17: ( ']]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINK_END
 *
 * Looks to match the characters the constitute the token LINK_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINK_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LINK_END;
       
    
    // WikiText.g:97:17: ( ']]' )
    // WikiText.g:97:19: ']]'
    {
        MATCHS(lit_9); 
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINK_ENDEx; /* Prevent compiler warnings */
    ruleLINK_ENDEx: ;

}
// $ANTLR end LINK_END

//   Comes from: 98:17: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXT_LINK_START
 *
 * Looks to match the characters the constitute the token EXT_LINK_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXT_LINK_START(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = EXT_LINK_START;
       
    
    // WikiText.g:98:17: ( '[' )
    // WikiText.g:98:19: '['
    {
        MATCHC('['); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXT_LINK_STARTEx; /* Prevent compiler warnings */
    ruleEXT_LINK_STARTEx: ;

}
// $ANTLR end EXT_LINK_START

//   Comes from: 99:17: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXT_LINK_END
 *
 * Looks to match the characters the constitute the token EXT_LINK_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXT_LINK_END(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = EXT_LINK_END;
       
    
    // WikiText.g:99:17: ( ']' )
    // WikiText.g:99:19: ']'
    {
        MATCHC(']'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXT_LINK_ENDEx; /* Prevent compiler warnings */
    ruleEXT_LINK_ENDEx: ;

}
// $ANTLR end EXT_LINK_END

//   Comes from: 100:17: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEPARATOR
 *
 * Looks to match the characters the constitute the token SEPARATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEPARATOR(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = SEPARATOR;
       
    
    // WikiText.g:100:17: ( '|' )
    // WikiText.g:100:19: '|'
    {
        MATCHC('|'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSEPARATOREx; /* Prevent compiler warnings */
    ruleSEPARATOREx: ;

}
// $ANTLR end SEPARATOR

//   Comes from: 101:17: ( ' ' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPACE
 *
 * Looks to match the characters the constitute the token SPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSPACE(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = SPACE;
       
    
    // WikiText.g:101:17: ( ' ' )
    // WikiText.g:101:19: ' '
    {
        MATCHC(' '); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSPACEEx; /* Prevent compiler warnings */
    ruleSPACEEx: ;

}
// $ANTLR end SPACE

//   Comes from: 103:17: ( NAMED_ENTITY | HEX_ENTITY | DECIMAL_ENTITY )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ENTITY
 *
 * Looks to match the characters the constitute the token ENTITY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mENTITY(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = ENTITY;
       
    
    {
        //  WikiText.g:103:17: ( NAMED_ENTITY | HEX_ENTITY | DECIMAL_ENTITY )
        
        ANTLR3_UINT32 alt19;

        alt19=3;


        {
            int LA19_0 = LA(1);
            if ( (LA19_0 == '&') ) 
            {

                {
                    int LA19_1 = LA(2);
                    if ( (LA19_1 == '#') ) 
                    {

                        {
                            int LA19_2 = LA(3);
                            if ( (LA19_2 == 'x') ) 
                            {
                                alt19=2;
                            }
                            else if ( (((LA19_2 >= '0') && (LA19_2 <= '9'))) ) 
                            {
                                alt19=3;
                            }
                            else 
                            {
                                if (BACKTRACKING>0)
                                {
                                    FAILEDFLAG = ANTLR3_TRUE; 
                                    return ;
                                }
                            
                                CONSTRUCTEX();
                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                EXCEPTION->message      = "103:1: ENTITY : ( NAMED_ENTITY | HEX_ENTITY | DECIMAL_ENTITY );";
                                EXCEPTION->decisionNum  = 19;
                                EXCEPTION->state        = 2;

                            
                                goto ruleENTITYEx;
                            }
                        }
                    }
                    else if ( (((LA19_1 >= 'A') && (LA19_1 <= 'Z')) || ((LA19_1 >= 'a') && (LA19_1 <= 'z'))) ) 
                    {
                        alt19=1;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "103:1: ENTITY : ( NAMED_ENTITY | HEX_ENTITY | DECIMAL_ENTITY );";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 1;

                    
                        goto ruleENTITYEx;
                    }
                }
            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return ;
                }
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "103:1: ENTITY : ( NAMED_ENTITY | HEX_ENTITY | DECIMAL_ENTITY );";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;

            
                goto ruleENTITYEx;
            }
        }
        switch (alt19) 
        {
    	case 1:
    	    // WikiText.g:103:19: NAMED_ENTITY
    	    {
    	        /* 103:19: NAMED_ENTITY */
    	        mNAMED_ENTITY(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // WikiText.g:103:34: HEX_ENTITY
    	    {
    	        /* 103:34: HEX_ENTITY */
    	        mHEX_ENTITY(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // WikiText.g:103:47: DECIMAL_ENTITY
    	    {
    	        /* 103:47: DECIMAL_ENTITY */
    	        mDECIMAL_ENTITY(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }
	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleENTITYEx; /* Prevent compiler warnings */
    ruleENTITYEx: ;

}
// $ANTLR end ENTITY

//   Comes from: 107:17: ( '&' ( 'a' .. 'z' | 'A' .. 'Z' )+ ( '0' .. '9' )* ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAMED_ENTITY
 *
 * Looks to match the characters the constitute the token NAMED_ENTITY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNAMED_ENTITY(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:107:17: ( '&' ( 'a' .. 'z' | 'A' .. 'Z' )+ ( '0' .. '9' )* ';' )
    // WikiText.g:107:20: '&' ( 'a' .. 'z' | 'A' .. 'Z' )+ ( '0' .. '9' )* ';'
    {
        MATCHC('&'); 
        if (HASFAILED())
        {
            return ;
        }
        // WikiText.g:107:24: ( 'a' .. 'z' | 'A' .. 'Z' )+
        {
            int cnt20=0;

            for (;;)
            {
                int alt20=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA20_0 = LA(1);
        	    if ( (((LA20_0 >= 'A') && (LA20_0 <= 'Z')) || ((LA20_0 >= 'a') && (LA20_0 <= 'z'))) ) 
        	    {
        	        alt20=1;
        	    }

        	}
        	switch (alt20) 
        	{
        	    case 1:
        	        // WikiText.g:
        	        {
        	            if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	            {
        	                CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleNAMED_ENTITYEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt20 >= 1 )
        		{
        		    goto loop20;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleNAMED_ENTITYEx;
        	}
        	cnt20++;
            }
            loop20: ;	/* Jump to here if this rule does not match */
        }

        // WikiText.g:107:47: ( '0' .. '9' )*

        for (;;)
        {
            int alt21=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA21_0 = LA(1);
                if ( (((LA21_0 >= '0') && (LA21_0 <= '9'))) ) 
                {
                    alt21=1;
                }

            }
            switch (alt21) 
            {
        	case 1:
        	    // WikiText.g:107:48: '0' .. '9'
        	    {
        	        MATCHRANGE('0', '9'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop21;	/* break out of the loop */
        	    break;
            }
        }
        loop21: ; /* Jump out to here if this rule does not match */

        MATCHC(';'); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleNAMED_ENTITYEx; /* Prevent compiler warnings */
    ruleNAMED_ENTITYEx: ;

}
// $ANTLR end NAMED_ENTITY

//   Comes from: 116:17: ( '&#x' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )+ ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_ENTITY
 *
 * Looks to match the characters the constitute the token HEX_ENTITY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_ENTITY(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:116:17: ( '&#x' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )+ ';' )
    // WikiText.g:116:19: '&#x' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )+ ';'
    {
        MATCHS(lit_10); 
        if (HASFAILED())
        {
            return ;
        }

        // WikiText.g:116:25: ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )+
        {
            int cnt22=0;

            for (;;)
            {
                int alt22=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA22_0 = LA(1);
        	    if ( (((LA22_0 >= '0') && (LA22_0 <= '9')) || ((LA22_0 >= 'A') && (LA22_0 <= 'F')) || ((LA22_0 >= 'a') && (LA22_0 <= 'f'))) ) 
        	    {
        	        alt22=1;
        	    }

        	}
        	switch (alt22) 
        	{
        	    case 1:
        	        // WikiText.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        	            {
        	                CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE; 
        	                    return ;
        	                }
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleHEX_ENTITYEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt22 >= 1 )
        		{
        		    goto loop22;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_ENTITYEx;
        	}
        	cnt22++;
            }
            loop22: ;	/* Jump to here if this rule does not match */
        }
        MATCHC(';'); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_ENTITYEx; /* Prevent compiler warnings */
    ruleHEX_ENTITYEx: ;

}
// $ANTLR end HEX_ENTITY

//   Comes from: 119:17: ( '&#' ( '0' .. '9' )+ ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_ENTITY
 *
 * Looks to match the characters the constitute the token DECIMAL_ENTITY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_ENTITY(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // WikiText.g:119:17: ( '&#' ( '0' .. '9' )+ ';' )
    // WikiText.g:119:19: '&#' ( '0' .. '9' )+ ';'
    {
        MATCHS(lit_11); 
        if (HASFAILED())
        {
            return ;
        }

        // WikiText.g:119:24: ( '0' .. '9' )+
        {
            int cnt23=0;

            for (;;)
            {
                int alt23=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA23_0 = LA(1);
        	    if ( (((LA23_0 >= '0') && (LA23_0 <= '9'))) ) 
        	    {
        	        alt23=1;
        	    }

        	}
        	switch (alt23) 
        	{
        	    case 1:
        	        // WikiText.g:119:24: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt23 >= 1 )
        		{
        		    goto loop23;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE; 
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = ANTLR3_EARLY_EXIT_NAME;


        		goto ruleDECIMAL_ENTITYEx;
        	}
        	cnt23++;
            }
            loop23: ;	/* Jump to here if this rule does not match */
        }
        MATCHC(';'); 
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_ENTITYEx; /* Prevent compiler warnings */
    ruleDECIMAL_ENTITYEx: ;

}
// $ANTLR end DECIMAL_ENTITY

//   Comes from: 127:17: ( '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOT
 *
 * Looks to match the characters the constitute the token QUOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUOT(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = QUOT;
       
    
    // WikiText.g:127:17: ( '\"' )
    // WikiText.g:127:19: '\"'
    {
        MATCHC('"'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUOTEx; /* Prevent compiler warnings */
    ruleQUOTEx: ;

}
// $ANTLR end QUOT

//   Comes from: 128:17: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AMP
 *
 * Looks to match the characters the constitute the token AMP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAMP(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = AMP;
       
    
    // WikiText.g:128:17: ( '&' )
    // WikiText.g:128:19: '&'
    {
        MATCHC('&'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleAMPEx; /* Prevent compiler warnings */
    ruleAMPEx: ;

}
// $ANTLR end AMP

//   Comes from: 129:17: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS
 *
 * Looks to match the characters the constitute the token LESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = LESS;
       
    
    // WikiText.g:129:17: ( '<' )
    // WikiText.g:129:19: '<'
    {
        MATCHC('<'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLESSEx; /* Prevent compiler warnings */
    ruleLESSEx: ;

}
// $ANTLR end LESS

//   Comes from: 130:17: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER
 *
 * Looks to match the characters the constitute the token GREATER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = GREATER;
       
    
    // WikiText.g:130:17: ( '>' )
    // WikiText.g:130:19: '>'
    {
        MATCHC('>'); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGREATEREx; /* Prevent compiler warnings */
    ruleGREATEREx: ;

}
// $ANTLR end GREATER

//   Comes from: 135:17: ( ( ( '\\r' )? '\\n' )=> ( '\\r' )? '\\n' | '\\r' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CRLF
 *
 * Looks to match the characters the constitute the token CRLF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCRLF(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = CRLF;
       
    
    {
        //  WikiText.g:135:17: ( ( ( '\\r' )? '\\n' )=> ( '\\r' )? '\\n' | '\\r' )
        
        ANTLR3_UINT32 alt25;

        alt25=2;


        {
            int LA25_0 = LA(1);
            if ( (LA25_0 == '\r') ) 
            {

                {
                    int LA25_1 = LA(2);
                    if ( (LA25_1 == '\n') && (synpred2(ctx))) 
                    {
                        alt25=1;
                    }
                    else 
                    {
                        alt25=2;    }
                }
            }
            else if ( (LA25_0 == '\n') && (synpred2(ctx))) 
            {
                alt25=1;
            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return ;
                }
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "135:1: CRLF : ( ( ( '\\r' )? '\\n' )=> ( '\\r' )? '\\n' | '\\r' );";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;

            
                goto ruleCRLFEx;
            }
        }
        switch (alt25) 
        {
    	case 1:
    	    // WikiText.g:135:19: ( ( '\\r' )? '\\n' )=> ( '\\r' )? '\\n'
    	    {

    	        // WikiText.g:135:34: ( '\\r' )?
    	        {
    	            int alt24=2;
    	            {
    	                int LA24_0 = LA(1);
    	                if ( (LA24_0 == '\r') ) 
    	                {
    	                    alt24=1;
    	                }
    	            }
    	            switch (alt24) 
    	            {
    	        	case 1:
    	        	    // WikiText.g:135:34: '\\r'
    	        	    {
    	        	        MATCHC('\r'); 
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }
    	        MATCHC('\n'); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // WikiText.g:136:19: '\\r'
    	    {
    	        MATCHC('\r'); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }
	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCRLFEx; /* Prevent compiler warnings */
    ruleCRLFEx: ;

}
// $ANTLR end CRLF

//   Comes from: 142:17: ( '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' | '\\u003F' .. '\\u007B' | '\\u007E' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRINTABLE
 *
 * Looks to match the characters the constitute the token PRINTABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRINTABLE(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = PRINTABLE;
       
    
    // WikiText.g:142:17: ( '\\u0021' | '\\u0023' .. '\\u0025' | '\\u0027' .. '\\u003B' | '\\u003D' | '\\u003F' .. '\\u007B' | '\\u007E' )
    // WikiText.g:
    {
        if ( LA(1) == '!' || ((LA(1) >= '#') && (LA(1) <= '%')) || ((LA(1) >= '\'') && (LA(1) <= ';')) || LA(1) == '=' || ((LA(1) >= '?') && (LA(1) <= '{')) || LA(1) == '~' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE; 
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto rulePRINTABLEEx;
        }


    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePRINTABLEEx; /* Prevent compiler warnings */
    rulePRINTABLEEx: ;

}
// $ANTLR end PRINTABLE

//   Comes from: 152:17: ( . )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEFAULT
 *
 * Looks to match the characters the constitute the token DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEFAULT(pWikiTextLexer ctx)
{
	ANTLR3_UINT32	_type;

   
    _type	    = DEFAULT;
       
    
    // WikiText.g:152:17: ( . )
    // WikiText.g:152:19: .
    {
        MATCHANY(); 
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXER->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDEFAULTEx; /* Prevent compiler warnings */
    ruleDEFAULTEx: ;

}
// $ANTLR end DEFAULT

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pWikiTextLexer ctx)
{
    {
        //  WikiText.g:1:39: ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT )
        
        ANTLR3_UINT32 alt26;

        alt26=38;


        {
            int LA26_0 = LA(1);
            if ( (LA26_0 == ' ') ) 
            {

                {
                    int LA26_1 = LA(2);
                    if ( (( (synpred3(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=1;
                    }
                    else if ( (synpred32(ctx)) ) 
                    {
                        alt26=30;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 1;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '<') ) 
            {

                {
                    int LA26_2 = LA(2);
                    if ( (synpred4(ctx)) ) 
                    {
                        alt26=2;
                    }
                    else if ( (synpred5(ctx)) ) 
                    {
                        alt26=3;
                    }
                    else if ( (synpred10(ctx)) ) 
                    {
                        alt26=8;
                    }
                    else if ( (synpred11(ctx)) ) 
                    {
                        alt26=9;
                    }
                    else if ( (synpred36(ctx)) ) 
                    {
                        alt26=34;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 2;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '>') ) 
            {

                {
                    int LA26_3 = LA(2);
                    if ( (( (synpred6(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=4;
                    }
                    else if ( (synpred37(ctx)) ) 
                    {
                        alt26=35;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 3;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '\'') ) 
            {

                {
                    int LA26_4 = LA(2);
                    if ( (synpred7(ctx)) ) 
                    {
                        alt26=5;
                    }
                    else if ( (synpred8(ctx)) ) 
                    {
                        alt26=6;
                    }
                    else if ( (synpred9(ctx)) ) 
                    {
                        alt26=7;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 4;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '#') ) 
            {

                {
                    int LA26_5 = LA(2);
                    if ( (( (synpred12(ctx)) && ( COLUMN == 0 || LAST_TOKEN == OL || LAST_TOKEN == UL || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=10;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 5;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '*') ) 
            {

                {
                    int LA26_6 = LA(2);
                    if ( (( (synpred13(ctx)) && ( COLUMN == 0 || LAST_TOKEN == UL || LAST_TOKEN == OL || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=11;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 6;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '=') ) 
            {

                {
                    int LA26_7 = LA(2);
                    if ( (( (synpred14(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=12;
                    }
                    else if ( (( (synpred15(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=13;
                    }
                    else if ( (( (synpred16(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=14;
                    }
                    else if ( (( (synpred17(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=15;
                    }
                    else if ( (( (synpred18(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=16;
                    }
                    else if ( (( (synpred19(ctx)) && ( COLUMN == 0 || LAST_TOKEN == BLOCKQUOTE ) )) ) 
                    {
                        alt26=17;
                    }
                    else if ( (synpred20(ctx)) ) 
                    {
                        alt26=18;
                    }
                    else if ( (synpred21(ctx)) ) 
                    {
                        alt26=19;
                    }
                    else if ( (synpred22(ctx)) ) 
                    {
                        alt26=20;
                    }
                    else if ( (synpred23(ctx)) ) 
                    {
                        alt26=21;
                    }
                    else if ( (synpred24(ctx)) ) 
                    {
                        alt26=22;
                    }
                    else if ( (synpred25(ctx)) ) 
                    {
                        alt26=23;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 7;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == 'H' || LA26_0 == 'h') ) 
            {

                {
                    int LA26_8 = LA(2);
                    if ( (synpred26(ctx)) ) 
                    {
                        alt26=24;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 8;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == 'F' || LA26_0 == 'f') ) 
            {

                {
                    int LA26_9 = LA(2);
                    if ( (synpred26(ctx)) ) 
                    {
                        alt26=24;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 9;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == 'S' || LA26_0 == 's') ) 
            {

                {
                    int LA26_10 = LA(2);
                    if ( (synpred26(ctx)) ) 
                    {
                        alt26=24;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 10;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '[') ) 
            {

                {
                    int LA26_11 = LA(2);
                    if ( (synpred27(ctx)) ) 
                    {
                        alt26=25;
                    }
                    else if ( (synpred29(ctx)) ) 
                    {
                        alt26=27;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 11;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == ']') ) 
            {

                {
                    int LA26_12 = LA(2);
                    if ( (synpred28(ctx)) ) 
                    {
                        alt26=26;
                    }
                    else if ( (synpred30(ctx)) ) 
                    {
                        alt26=28;
                    }
                    else if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 12;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '|') ) 
            {

                {
                    int LA26_13 = LA(2);
                    if ( (synpred31(ctx)) ) 
                    {
                        alt26=29;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 13;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '&') ) 
            {

                {
                    int LA26_14 = LA(2);
                    if ( (synpred33(ctx)) ) 
                    {
                        alt26=31;
                    }
                    else if ( (synpred35(ctx)) ) 
                    {
                        alt26=33;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 14;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '"') ) 
            {

                {
                    int LA26_15 = LA(2);
                    if ( (synpred34(ctx)) ) 
                    {
                        alt26=32;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 15;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '\r') ) 
            {

                {
                    int LA26_16 = LA(2);
                    if ( (synpred38(ctx)) ) 
                    {
                        alt26=36;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 16;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '\n') ) 
            {

                {
                    int LA26_17 = LA(2);
                    if ( (synpred38(ctx)) ) 
                    {
                        alt26=36;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 17;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (LA26_0 == '!' || ((LA26_0 >= '$') && (LA26_0 <= '%')) || ((LA26_0 >= '(') && (LA26_0 <= ')')) || ((LA26_0 >= '+') && (LA26_0 <= ';')) || ((LA26_0 >= '?') && (LA26_0 <= 'E')) || LA26_0 == 'G' || ((LA26_0 >= 'I') && (LA26_0 <= 'R')) || ((LA26_0 >= 'T') && (LA26_0 <= 'Z')) || LA26_0 == '\\' || ((LA26_0 >= '^') && (LA26_0 <= 'e')) || LA26_0 == 'g' || ((LA26_0 >= 'i') && (LA26_0 <= 'r')) || ((LA26_0 >= 't') && (LA26_0 <= '{')) || LA26_0 == '~') ) 
            {

                {
                    int LA26_18 = LA(2);
                    if ( (synpred39(ctx)) ) 
                    {
                        alt26=37;
                    }
                    else if ( (ANTLR3_TRUE) ) 
                    {
                        alt26=38;
                    }
                    else 
                    {
                        if (BACKTRACKING>0)
                        {
                            FAILEDFLAG = ANTLR3_TRUE; 
                            return ;
                        }
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                        EXCEPTION->decisionNum  = 26;
                        EXCEPTION->state        = 18;

                    
                        goto ruleTokensEx;
                    }
                }
            }
            else if ( (((LA26_0 >= 0x0000) && (LA26_0 <= '\t')) || ((LA26_0 >= 0x000B) && (LA26_0 <= '\f')) || ((LA26_0 >= 0x000E) && (LA26_0 <= 0x001F)) || LA26_0 == '}' || ((LA26_0 >= 0x007F) && (LA26_0 <= 0xFFFE))) ) 
            {
                alt26=38;
            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE; 
                    return ;
                }
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = "1:1: Tokens options {k=1; backtrack=true; } : ( PRE | NO_WIKI_START | NO_WIKI_END | BLOCKQUOTE | STRONG_EM | STRONG | EM | TT_START | TT_END | OL | UL | H6_START | H5_START | H4_START | H3_START | H2_START | H1_START | H6_END | H5_END | H4_END | H3_END | H2_END | H1_END | URI | LINK_START | LINK_END | EXT_LINK_START | EXT_LINK_END | SEPARATOR | SPACE | ENTITY | QUOT | AMP | LESS | GREATER | CRLF | PRINTABLE | DEFAULT );";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;

            
                goto ruleTokensEx;
            }
        }
        switch (alt26) 
        {
    	case 1:
    	    // WikiText.g:1:41: PRE
    	    {
    	        /* 1:41: PRE */
    	        mPRE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // WikiText.g:1:45: NO_WIKI_START
    	    {
    	        /* 1:45: NO_WIKI_START */
    	        mNO_WIKI_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // WikiText.g:1:59: NO_WIKI_END
    	    {
    	        /* 1:59: NO_WIKI_END */
    	        mNO_WIKI_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 4:
    	    // WikiText.g:1:71: BLOCKQUOTE
    	    {
    	        /* 1:71: BLOCKQUOTE */
    	        mBLOCKQUOTE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 5:
    	    // WikiText.g:1:82: STRONG_EM
    	    {
    	        /* 1:82: STRONG_EM */
    	        mSTRONG_EM(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 6:
    	    // WikiText.g:1:92: STRONG
    	    {
    	        /* 1:92: STRONG */
    	        mSTRONG(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 7:
    	    // WikiText.g:1:99: EM
    	    {
    	        /* 1:99: EM */
    	        mEM(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 8:
    	    // WikiText.g:1:102: TT_START
    	    {
    	        /* 1:102: TT_START */
    	        mTT_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 9:
    	    // WikiText.g:1:111: TT_END
    	    {
    	        /* 1:111: TT_END */
    	        mTT_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 10:
    	    // WikiText.g:1:118: OL
    	    {
    	        /* 1:118: OL */
    	        mOL(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 11:
    	    // WikiText.g:1:121: UL
    	    {
    	        /* 1:121: UL */
    	        mUL(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 12:
    	    // WikiText.g:1:124: H6_START
    	    {
    	        /* 1:124: H6_START */
    	        mH6_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 13:
    	    // WikiText.g:1:133: H5_START
    	    {
    	        /* 1:133: H5_START */
    	        mH5_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 14:
    	    // WikiText.g:1:142: H4_START
    	    {
    	        /* 1:142: H4_START */
    	        mH4_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 15:
    	    // WikiText.g:1:151: H3_START
    	    {
    	        /* 1:151: H3_START */
    	        mH3_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 16:
    	    // WikiText.g:1:160: H2_START
    	    {
    	        /* 1:160: H2_START */
    	        mH2_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 17:
    	    // WikiText.g:1:169: H1_START
    	    {
    	        /* 1:169: H1_START */
    	        mH1_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 18:
    	    // WikiText.g:1:178: H6_END
    	    {
    	        /* 1:178: H6_END */
    	        mH6_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 19:
    	    // WikiText.g:1:185: H5_END
    	    {
    	        /* 1:185: H5_END */
    	        mH5_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 20:
    	    // WikiText.g:1:192: H4_END
    	    {
    	        /* 1:192: H4_END */
    	        mH4_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 21:
    	    // WikiText.g:1:199: H3_END
    	    {
    	        /* 1:199: H3_END */
    	        mH3_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 22:
    	    // WikiText.g:1:206: H2_END
    	    {
    	        /* 1:206: H2_END */
    	        mH2_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 23:
    	    // WikiText.g:1:213: H1_END
    	    {
    	        /* 1:213: H1_END */
    	        mH1_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 24:
    	    // WikiText.g:1:220: URI
    	    {
    	        /* 1:220: URI */
    	        mURI(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 25:
    	    // WikiText.g:1:224: LINK_START
    	    {
    	        /* 1:224: LINK_START */
    	        mLINK_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 26:
    	    // WikiText.g:1:235: LINK_END
    	    {
    	        /* 1:235: LINK_END */
    	        mLINK_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 27:
    	    // WikiText.g:1:244: EXT_LINK_START
    	    {
    	        /* 1:244: EXT_LINK_START */
    	        mEXT_LINK_START(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 28:
    	    // WikiText.g:1:259: EXT_LINK_END
    	    {
    	        /* 1:259: EXT_LINK_END */
    	        mEXT_LINK_END(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 29:
    	    // WikiText.g:1:272: SEPARATOR
    	    {
    	        /* 1:272: SEPARATOR */
    	        mSEPARATOR(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 30:
    	    // WikiText.g:1:282: SPACE
    	    {
    	        /* 1:282: SPACE */
    	        mSPACE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 31:
    	    // WikiText.g:1:288: ENTITY
    	    {
    	        /* 1:288: ENTITY */
    	        mENTITY(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 32:
    	    // WikiText.g:1:295: QUOT
    	    {
    	        /* 1:295: QUOT */
    	        mQUOT(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 33:
    	    // WikiText.g:1:300: AMP
    	    {
    	        /* 1:300: AMP */
    	        mAMP(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 34:
    	    // WikiText.g:1:304: LESS
    	    {
    	        /* 1:304: LESS */
    	        mLESS(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 35:
    	    // WikiText.g:1:309: GREATER
    	    {
    	        /* 1:309: GREATER */
    	        mGREATER(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 36:
    	    // WikiText.g:1:317: CRLF
    	    {
    	        /* 1:317: CRLF */
    	        mCRLF(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 37:
    	    // WikiText.g:1:322: PRINTABLE
    	    {
    	        /* 1:322: PRINTABLE */
    	        mPRINTABLE(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 38:
    	    // WikiText.g:1:332: DEFAULT
    	    {
    	        /* 1:332: DEFAULT */
    	        mDEFAULT(ctx ); 
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1
static void synpred1_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:77:51: ( SPECIAL_URI_CHARS URI_CHARS )
    // WikiText.g:77:52: SPECIAL_URI_CHARS URI_CHARS
    {
        /* 77:52: SPECIAL_URI_CHARS URI_CHARS */
        mSPECIAL_URI_CHARS(ctx ); 
        if (HASFAILED())
        {
            return ;
        }
        /* 77:52: SPECIAL_URI_CHARS URI_CHARS */
        mURI_CHARS(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1Ex; /* Prevent compiler warnings */
rulesynpred1Ex: ;

}
// $ANTLR end synpred1

// $ANTLR start synpred2
static void synpred2_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:135:19: ( ( '\\r' )? '\\n' )
    // WikiText.g:135:20: ( '\\r' )? '\\n'
    {

        // WikiText.g:135:20: ( '\\r' )?
        {
            int alt27=2;
            {
                int LA27_0 = LA(1);
                if ( (LA27_0 == '\r') ) 
                {
                    alt27=1;
                }
            }
            switch (alt27) 
            {
        	case 1:
        	    // WikiText.g:135:20: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2Ex; /* Prevent compiler warnings */
rulesynpred2Ex: ;

}
// $ANTLR end synpred2

// $ANTLR start synpred3
static void synpred3_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:41: ( PRE )
    // WikiText.g:1:41: PRE
    {
        /* 1:41: PRE */
        mPRE(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred3Ex; /* Prevent compiler warnings */
rulesynpred3Ex: ;

}
// $ANTLR end synpred3

// $ANTLR start synpred4
static void synpred4_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:45: ( NO_WIKI_START )
    // WikiText.g:1:45: NO_WIKI_START
    {
        /* 1:45: NO_WIKI_START */
        mNO_WIKI_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred4Ex; /* Prevent compiler warnings */
rulesynpred4Ex: ;

}
// $ANTLR end synpred4

// $ANTLR start synpred5
static void synpred5_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:59: ( NO_WIKI_END )
    // WikiText.g:1:59: NO_WIKI_END
    {
        /* 1:59: NO_WIKI_END */
        mNO_WIKI_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred5Ex; /* Prevent compiler warnings */
rulesynpred5Ex: ;

}
// $ANTLR end synpred5

// $ANTLR start synpred6
static void synpred6_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:71: ( BLOCKQUOTE )
    // WikiText.g:1:71: BLOCKQUOTE
    {
        /* 1:71: BLOCKQUOTE */
        mBLOCKQUOTE(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred6Ex; /* Prevent compiler warnings */
rulesynpred6Ex: ;

}
// $ANTLR end synpred6

// $ANTLR start synpred7
static void synpred7_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:82: ( STRONG_EM )
    // WikiText.g:1:82: STRONG_EM
    {
        /* 1:82: STRONG_EM */
        mSTRONG_EM(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred7Ex; /* Prevent compiler warnings */
rulesynpred7Ex: ;

}
// $ANTLR end synpred7

// $ANTLR start synpred8
static void synpred8_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:92: ( STRONG )
    // WikiText.g:1:92: STRONG
    {
        /* 1:92: STRONG */
        mSTRONG(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred8Ex; /* Prevent compiler warnings */
rulesynpred8Ex: ;

}
// $ANTLR end synpred8

// $ANTLR start synpred9
static void synpred9_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:99: ( EM )
    // WikiText.g:1:99: EM
    {
        /* 1:99: EM */
        mEM(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred9Ex; /* Prevent compiler warnings */
rulesynpred9Ex: ;

}
// $ANTLR end synpred9

// $ANTLR start synpred10
static void synpred10_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:102: ( TT_START )
    // WikiText.g:1:102: TT_START
    {
        /* 1:102: TT_START */
        mTT_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred10Ex; /* Prevent compiler warnings */
rulesynpred10Ex: ;

}
// $ANTLR end synpred10

// $ANTLR start synpred11
static void synpred11_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:111: ( TT_END )
    // WikiText.g:1:111: TT_END
    {
        /* 1:111: TT_END */
        mTT_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred11Ex; /* Prevent compiler warnings */
rulesynpred11Ex: ;

}
// $ANTLR end synpred11

// $ANTLR start synpred12
static void synpred12_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:118: ( OL )
    // WikiText.g:1:118: OL
    {
        /* 1:118: OL */
        mOL(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred12Ex; /* Prevent compiler warnings */
rulesynpred12Ex: ;

}
// $ANTLR end synpred12

// $ANTLR start synpred13
static void synpred13_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:121: ( UL )
    // WikiText.g:1:121: UL
    {
        /* 1:121: UL */
        mUL(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred13Ex; /* Prevent compiler warnings */
rulesynpred13Ex: ;

}
// $ANTLR end synpred13

// $ANTLR start synpred14
static void synpred14_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:124: ( H6_START )
    // WikiText.g:1:124: H6_START
    {
        /* 1:124: H6_START */
        mH6_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred14Ex; /* Prevent compiler warnings */
rulesynpred14Ex: ;

}
// $ANTLR end synpred14

// $ANTLR start synpred15
static void synpred15_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:133: ( H5_START )
    // WikiText.g:1:133: H5_START
    {
        /* 1:133: H5_START */
        mH5_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred15Ex; /* Prevent compiler warnings */
rulesynpred15Ex: ;

}
// $ANTLR end synpred15

// $ANTLR start synpred16
static void synpred16_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:142: ( H4_START )
    // WikiText.g:1:142: H4_START
    {
        /* 1:142: H4_START */
        mH4_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred16Ex; /* Prevent compiler warnings */
rulesynpred16Ex: ;

}
// $ANTLR end synpred16

// $ANTLR start synpred17
static void synpred17_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:151: ( H3_START )
    // WikiText.g:1:151: H3_START
    {
        /* 1:151: H3_START */
        mH3_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred17Ex; /* Prevent compiler warnings */
rulesynpred17Ex: ;

}
// $ANTLR end synpred17

// $ANTLR start synpred18
static void synpred18_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:160: ( H2_START )
    // WikiText.g:1:160: H2_START
    {
        /* 1:160: H2_START */
        mH2_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred18Ex; /* Prevent compiler warnings */
rulesynpred18Ex: ;

}
// $ANTLR end synpred18

// $ANTLR start synpred19
static void synpred19_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:169: ( H1_START )
    // WikiText.g:1:169: H1_START
    {
        /* 1:169: H1_START */
        mH1_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred19Ex; /* Prevent compiler warnings */
rulesynpred19Ex: ;

}
// $ANTLR end synpred19

// $ANTLR start synpred20
static void synpred20_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:178: ( H6_END )
    // WikiText.g:1:178: H6_END
    {
        /* 1:178: H6_END */
        mH6_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred20Ex; /* Prevent compiler warnings */
rulesynpred20Ex: ;

}
// $ANTLR end synpred20

// $ANTLR start synpred21
static void synpred21_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:185: ( H5_END )
    // WikiText.g:1:185: H5_END
    {
        /* 1:185: H5_END */
        mH5_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred21Ex; /* Prevent compiler warnings */
rulesynpred21Ex: ;

}
// $ANTLR end synpred21

// $ANTLR start synpred22
static void synpred22_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:192: ( H4_END )
    // WikiText.g:1:192: H4_END
    {
        /* 1:192: H4_END */
        mH4_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred22Ex; /* Prevent compiler warnings */
rulesynpred22Ex: ;

}
// $ANTLR end synpred22

// $ANTLR start synpred23
static void synpred23_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:199: ( H3_END )
    // WikiText.g:1:199: H3_END
    {
        /* 1:199: H3_END */
        mH3_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred23Ex; /* Prevent compiler warnings */
rulesynpred23Ex: ;

}
// $ANTLR end synpred23

// $ANTLR start synpred24
static void synpred24_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:206: ( H2_END )
    // WikiText.g:1:206: H2_END
    {
        /* 1:206: H2_END */
        mH2_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred24Ex; /* Prevent compiler warnings */
rulesynpred24Ex: ;

}
// $ANTLR end synpred24

// $ANTLR start synpred25
static void synpred25_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:213: ( H1_END )
    // WikiText.g:1:213: H1_END
    {
        /* 1:213: H1_END */
        mH1_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred25Ex; /* Prevent compiler warnings */
rulesynpred25Ex: ;

}
// $ANTLR end synpred25

// $ANTLR start synpred26
static void synpred26_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:220: ( URI )
    // WikiText.g:1:220: URI
    {
        /* 1:220: URI */
        mURI(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred26Ex; /* Prevent compiler warnings */
rulesynpred26Ex: ;

}
// $ANTLR end synpred26

// $ANTLR start synpred27
static void synpred27_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:224: ( LINK_START )
    // WikiText.g:1:224: LINK_START
    {
        /* 1:224: LINK_START */
        mLINK_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred27Ex; /* Prevent compiler warnings */
rulesynpred27Ex: ;

}
// $ANTLR end synpred27

// $ANTLR start synpred28
static void synpred28_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:235: ( LINK_END )
    // WikiText.g:1:235: LINK_END
    {
        /* 1:235: LINK_END */
        mLINK_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred28Ex; /* Prevent compiler warnings */
rulesynpred28Ex: ;

}
// $ANTLR end synpred28

// $ANTLR start synpred29
static void synpred29_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:244: ( EXT_LINK_START )
    // WikiText.g:1:244: EXT_LINK_START
    {
        /* 1:244: EXT_LINK_START */
        mEXT_LINK_START(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred29Ex; /* Prevent compiler warnings */
rulesynpred29Ex: ;

}
// $ANTLR end synpred29

// $ANTLR start synpred30
static void synpred30_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:259: ( EXT_LINK_END )
    // WikiText.g:1:259: EXT_LINK_END
    {
        /* 1:259: EXT_LINK_END */
        mEXT_LINK_END(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred30Ex; /* Prevent compiler warnings */
rulesynpred30Ex: ;

}
// $ANTLR end synpred30

// $ANTLR start synpred31
static void synpred31_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:272: ( SEPARATOR )
    // WikiText.g:1:272: SEPARATOR
    {
        /* 1:272: SEPARATOR */
        mSEPARATOR(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred31Ex; /* Prevent compiler warnings */
rulesynpred31Ex: ;

}
// $ANTLR end synpred31

// $ANTLR start synpred32
static void synpred32_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:282: ( SPACE )
    // WikiText.g:1:282: SPACE
    {
        /* 1:282: SPACE */
        mSPACE(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred32Ex; /* Prevent compiler warnings */
rulesynpred32Ex: ;

}
// $ANTLR end synpred32

// $ANTLR start synpred33
static void synpred33_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:288: ( ENTITY )
    // WikiText.g:1:288: ENTITY
    {
        /* 1:288: ENTITY */
        mENTITY(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred33Ex; /* Prevent compiler warnings */
rulesynpred33Ex: ;

}
// $ANTLR end synpred33

// $ANTLR start synpred34
static void synpred34_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:295: ( QUOT )
    // WikiText.g:1:295: QUOT
    {
        /* 1:295: QUOT */
        mQUOT(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred34Ex; /* Prevent compiler warnings */
rulesynpred34Ex: ;

}
// $ANTLR end synpred34

// $ANTLR start synpred35
static void synpred35_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:300: ( AMP )
    // WikiText.g:1:300: AMP
    {
        /* 1:300: AMP */
        mAMP(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred35Ex; /* Prevent compiler warnings */
rulesynpred35Ex: ;

}
// $ANTLR end synpred35

// $ANTLR start synpred36
static void synpred36_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:304: ( LESS )
    // WikiText.g:1:304: LESS
    {
        /* 1:304: LESS */
        mLESS(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred36Ex; /* Prevent compiler warnings */
rulesynpred36Ex: ;

}
// $ANTLR end synpred36

// $ANTLR start synpred37
static void synpred37_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:309: ( GREATER )
    // WikiText.g:1:309: GREATER
    {
        /* 1:309: GREATER */
        mGREATER(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred37Ex; /* Prevent compiler warnings */
rulesynpred37Ex: ;

}
// $ANTLR end synpred37

// $ANTLR start synpred38
static void synpred38_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:317: ( CRLF )
    // WikiText.g:1:317: CRLF
    {
        /* 1:317: CRLF */
        mCRLF(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred38Ex; /* Prevent compiler warnings */
rulesynpred38Ex: ;

}
// $ANTLR end synpred38

// $ANTLR start synpred39
static void synpred39_fragment(pWikiTextLexer ctx ) 
{   
    // WikiText.g:1:322: ( PRINTABLE )
    // WikiText.g:1:322: PRINTABLE
    {
        /* 1:322: PRINTABLE */
        mPRINTABLE(ctx ); 
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred39Ex; /* Prevent compiler warnings */
rulesynpred39Ex: ;

}
// $ANTLR end synpred39

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred25(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred25_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred7(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred7_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred37(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred37_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred14(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred14_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred15(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred15_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred30(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred30_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred22(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred22_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred38(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred38_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred27(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred27_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred12(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred12_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred31(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred31_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred9(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred9_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred39(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred39_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred20(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred20_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred17(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred17_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred28(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred28_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred36(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred36_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred33(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred33_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred29(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred29_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred18(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred18_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred11(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred11_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred32(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred32_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred34(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred34_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred26(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred26_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred8(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred8_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred10(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred10_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred21(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred21_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred23(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred23_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred16(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred16_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred35(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred35_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred19(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred19_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred24(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred24_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred5(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred5_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred6(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred6_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred13(pWikiTextLexer ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred13_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
